{"componentChunkName":"component---src-templates-blog-post-blog-post-js","path":"/blog/posts/elixir-has-opened-my-eyes","result":{"data":{"markdownRemark":{"html":"<p>Functional programming (FP) is a mythical beast to the fledging developer. It can seem daunting to approach the idea of designing systems with the idea of pure functions in mind and rightfully so. I was the same a couple of years back - right when I was starting to get into computer science. Coming from object-oriented programming (OOP), FP was like trying to fit a square peg into a round hole for me. My first exposure to FP was through streams in Java 8. Then, I moved onto Kotlin and Javascript which had better \"built-in\" support for FP-like syntax by focusing on developing a language that has first-class functions. Finally, I approached the beast: Elixir!</p>\n<p>Learning Elixir has been a joy, honestly. It filled the gaps that Kotlin and Javascript left as they had to accommodate for OOP. In order to practice Elixir, I decided to work on Advent of Code (AoC) 2020. Working on AoC highlighted the strengths of Elixir/FP and my weaknesses in recursion and problem solving without OOP. It has also trained me to write far cleaner code without wasting crucial man-hours writing convoluted code.</p>\n<p>Recently, I was reading some Kotlin code and the most unusual thing happened: I had no idea what I was reading! I certainly understood what the code was meant to do, but I didn't at the same time... The once elegant and easy to reason FP-esque code had become a challenge to interpret and that made me appreciate Elixir and \"proper\" FP more - specifically, function chaining, pattern matching, and guard clauses.</p>\n<h2 id=\"function-chaining\" style=\"position:relative;\"><a href=\"#function-chaining\" aria-label=\"function chaining permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Function chaining</h2>\n<p>Function chaining is by far the easiest of the three to explain so let's knock it out in one fell swoop.</p>\n<p>In Kotlin or Javascript, functions are chained as such:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\">lst<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">{</span> it <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">{</span> it <span class=\"token operator\">+</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This syntax is made possible because <code class=\"language-text\">lst</code> is a <code class=\"language-text\">List&lt;T&gt;</code> object and these objects have methods that provide such functionality (so really, we're performing method calling).</p>\n<p>In Elixir, however, we do not trifle with the mundane like objects or methods. Instead, we have modules. And in these modules, we have our functions. So, in order to chain function calls, we do not rely on object method calls, instead we do something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-elixir line-numbers\"><code class=\"language-elixir\">lst\n<span class=\"token operator\">|></span> Enum<span class=\"token punctuation\">.</span>filter<span class=\"token punctuation\">(</span><span class=\"token capture function\">&amp;is_even</span><span class=\"token punctuation\">(</span><span class=\"token argument variable\">&amp;1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">|></span> Enum<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span><span class=\"token capture function\">&amp;</span><span class=\"token punctuation\">(</span><span class=\"token argument variable\">&amp;1</span> <span class=\"token operator\">+</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>We are quite literally chaining <em>function</em> calls as opposed to chaining <em>method</em> calls.</p>\n<p><code class=\"language-text\">lst</code> is passed directly as the first parameter of the first function, then the result of <code class=\"language-text\">Enum.filter</code> is passed to the second function and so on.</p>\n<p>I like this syntax as opposed to method call chaining as it provides a clearer way of reading the code - where we do not worry about whether an object supports a given operation. We just focus on the data type of the input and pick the methods that suit this information.</p>\n<h2 id=\"pattern-matching\" style=\"position:relative;\"><a href=\"#pattern-matching\" aria-label=\"pattern matching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pattern matching</h2>\n<p>Traditionally, return values or arguments are often passed in a given format (list or map, etc.) and it is the function's responsibility to decode this structure in the function body. However, pattern matching eliminates this additional overhead by providing the necessary syntax for performing all of this decoding for us. Let's look at several examples and contrast them against \"traditional\" solutions written in more OOP-oriented languages.</p>\n<p>Let's say we declare a function that returns a tuple. This tuple represents a simple HTTP connection string: the URL and port. Let's see how we can write this in Kotlin:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">getConnString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"193.67.13.1\"</span> <span class=\"token keyword\">to</span> <span class=\"token string\">\"2203\"</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> connString <span class=\"token operator\">=</span> <span class=\"token function\">getConnString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">val</span> url <span class=\"token operator\">=</span> connString<span class=\"token punctuation\">.</span>first\n  <span class=\"token keyword\">val</span> port <span class=\"token operator\">=</span> connString<span class=\"token punctuation\">.</span>second\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Let's see how we would approach this in Elixir:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-elixir line-numbers\"><code class=\"language-elixir\"><span class=\"token keyword\">def</span> get_conn_string<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> \n  <span class=\"token punctuation\">{</span><span class=\"token string\">\"193.67.13.1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2203\"</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>  \n  <span class=\"token punctuation\">{</span>url<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> get_conn_string\n<span class=\"token keyword\">end</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>A keen Kotlin developer might argue that, \"Hey, since Kotlin already supports Pair unpacking, this problem is trivial right?\"</p>\n<p><strong>Wrong.</strong></p>\n<p>While Kotlin provides basic, single-level destructuring, it does not support far more complex ones, such as:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-elixir line-numbers\"><code class=\"language-elixir\"><span class=\"token keyword\">def</span> big_bag<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> \n  <span class=\"token punctuation\">{</span><span class=\"token string\">\"192.67.13.1\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"2203\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2204\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n  <span class=\"token punctuation\">{</span>address<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>primary_port<span class=\"token punctuation\">,</span> secondary_port<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> big_bag\n<span class=\"token keyword\">end</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Thread lightly for brave souls have tried but failed in achieving this level of destructuring in \"traditional\" OOP languages.</p>\n<p>But beyond a simple application of destructuring the return values of a function, we can also use pattern matching in our function parameters.</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-elixir line-numbers\"><code class=\"language-elixir\"><span class=\"token keyword\">def</span> read_conn<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>url<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>primary_port<span class=\"token punctuation\">,</span> secondary_port<span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> \n  <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span>url<span class=\"token delimiter punctuation\">}</span></span>:<span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span>primary_port<span class=\"token delimiter punctuation\">}</span></span>\"</span>\n<span class=\"token keyword\">end</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>Not only can we use pattern matching for destructuring parameters of a single function, we can use method overloading in conjunction with pattern matching to cater to corner cases in our parameters (more can be done with guard clauses but that is a topic I shall reserve till later on):</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-elixir line-numbers\"><code class=\"language-elixir\"><span class=\"token keyword\">def</span> ex<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>instruction <span class=\"token operator\">|</span> rest<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> ex<span class=\"token punctuation\">(</span>rest<span class=\"token punctuation\">,</span> result <span class=\"token operator\">++</span> instruction<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> ex<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> result</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>In this particular example, the function <code class=\"language-text\">ex</code> extracts the immediate instruction from the list of instructions and adds it to the result. It does so recursively until the list of instructions is empty. At that point, the function will simply return the list of instructions once again (recall that <code class=\"language-text\">result</code> simply holds the instructions in order).</p>\n<p>This recursive function is able to halt (or encounter a stop case) because pattern matching dictates that any non-empty list will call the function again while an empty list returns the <code class=\"language-text\">result</code>.</p>\n<p>You can also use pattern matching to detect when a function parameter (destructured) does not match a given format:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-elixir line-numbers\"><code class=\"language-elixir\"><span class=\"token keyword\">def</span> foo<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span>name<span class=\"token delimiter punctuation\">}</span></span>, <span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span>age<span class=\"token delimiter punctuation\">}</span></span>\"</span>\n<span class=\"token keyword\">def</span> foo<span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> <span class=\"token atom symbol\">:error</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Pretty cool innit? The official Elixir documentation talks about pattern matching in much greater detail but I wanted to highlight the applications of pattern matching that I found interesting.</p>\n<p>Pattern matching has allowed me to write far more concise code and that has been such a wonderful feature that I sorely miss now when I work on Kotlin codebases.</p>\n<h2 id=\"guard-clauses\" style=\"position:relative;\"><a href=\"#guard-clauses\" aria-label=\"guard clauses permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Guard clauses</h2>\n<p>Imagine we're writing an implementation of the Fibonacci sequence in Kotlin. In order to inform the program that we have hit a base case, we would often design the function to include the base case, as such:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-kotlin line-numbers\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">or</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>I don't know about you, but the if-statement just makes the code look untidy. Instead, we can use guard clauses to spruce this up a little:</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-elixir line-numbers\"><code class=\"language-elixir\"><span class=\"token keyword\">def</span> fib<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">when</span> n <span class=\"token operator\">in</span> <span class=\"token number\">0</span><span class=\"token operator\">..</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">def</span> fib<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">do:</span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>Rather than embedding an if-statement inside of the function, we overload the method with a guard clause - denoted by the <code class=\"language-text\">when</code> keyword. When the program executes, it checks every overload of the method and tries to match the patterns <strong>AND</strong> guard clauses to ensure the right function implementation is called.</p>\n<p>This is very useful as we can expand our code to account for many base cases without polluting the core behavior of the function. This allows us to design code that scales vertically (more functions), not horizontally (more if-statements).</p>\n<hr>\n<h2 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p><del>Elixir is cool and you should use it!</del></p>\n<p>In all honesty, Elixir has taught me to value OOP more, ironically. I have realised that I am very used to the OOP way of solving problems that my fundamental problem solving skills without this hammer has become extremely dull and I am very happy that Elixir has allowed me to express my code in an elegant manner. I cannot wait to try using Elixir to build sites using Phoenix!</p>","frontmatter":{"title":"Elixir has opened my eyes...","date":"29 December 2020","description":"How Elixir and functional programming has changed the way I look at problems","tags":["reflection","sharing","Elixir","Advent of Code 2020"]},"fields":{"slug":"/blog/posts/elixir-has-opened-my-eyes"}},"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/blog/posts/discovering-chrome-accounts"},"frontmatter":{"title":"Discovering Chrome accounts","published":true}}},{"node":{"fields":{"slug":"/blog/posts/open-source-deep-dive-hound"},"frontmatter":{"title":"Open-source Deep Dive: Hound","published":true}}}]}},"pageContext":{"slug":"/blog/posts/elixir-has-opened-my-eyes","next":"/blog/posts/open-source-deep-dive-hound","prev":"/blog/posts/discovering-chrome-accounts"}},"staticQueryHashes":["2068778362","2207116114"]}